/**
 * ⚠️ AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️
 *
 * This file is auto-generated by cli/generate-config.ts
 * Run 'npm run generate:config' to regenerate
 */

// =============================================================================
// Types
// =============================================================================

export interface ExampleConfig {
  /** Path to the Solidity contract file */
  contract: string;
  /** Path to the TypeScript test file */
  test: string;
  /** Optional additional contract dependencies */
  dependencies?: string[];
  /** Optional npm packages to install */
  npmDependencies?: Record<string, string>;
  /** Full description for documentation */
  description: string;
  /** Category for grouping */
  category: string;
  /** Output path for generated documentation */
  docsOutput: string;
  /** Title for documentation */
  title: string;
}

export interface CategoryConfig {
  /** Display name */
  name: string;
  /** List of contracts in this category */
  contracts: Array<{ sol: string; test?: string }>;
}

// =============================================================================
// Example Configurations
// =============================================================================

export const EXAMPLES: Record<string, ExampleConfig> = {
  "blind-auction": {
    contract: "contracts/advanced/BlindAuction.sol",
    test: "test/advanced/BlindAuction.ts",
    description:
      "Blind auction where bids remain encrypted until the end. Bidders submit encrypted amounts. The contract finds the highest bid using FHE.gt and FHE.select without ever decrypting losing bids. Only the winning bid amount is revealed after the auction closes. Losing bids remain private forever, ensuring true bid confidentiality.",
    category: "Advanced",
    docsOutput: "docs/advanced/blind-auction.md",
    title: "Blind Auction"
  },
  "encrypted-escrow": {
    contract: "contracts/advanced/EncryptedEscrow.sol",
    test: "test/advanced/EncryptedEscrow.ts",
    description:
      "Confidential escrow service with hidden transaction amounts. Buyer and seller agree on encrypted escrow amount. Funds are held securely until conditions are met. Amount remains hidden from public view until release or refund. Includes arbiter for dispute resolution. Perfect for high-value transactions requiring privacy.",
    category: "Advanced",
    docsOutput: "docs/advanced/encrypted-escrow.md",
    title: "Encrypted Escrow"
  },
  "hidden-voting": {
    contract: "contracts/advanced/HiddenVoting.sol",
    test: "test/advanced/HiddenVoting.ts",
    description:
      "Private voting system with homomorphic vote tallying. Voters submit encrypted ballots (Yes/No). Votes are tallied using homomorphic addition WITHOUT decrypting individual ballots. Only the final tally is revealed - individual votes remain private forever. Perfect for DAO governance, elections, or any scenario requiring ballot secrecy.",
    category: "Advanced",
    docsOutput: "docs/advanced/hidden-voting.md",
    title: "Hidden Voting"
  },
  "private-kyc": {
    contract: "contracts/advanced/PrivateKYC.sol",
    test: "test/advanced/PrivateKYC.ts",
    description:
      "Privacy-preserving identity verification using predicate proofs. Users submit encrypted personal data (age, country, credit score). Contract can verify predicates like \"Is user 18+?\" or \"Good credit?\" without learning the actual values. Returns encrypted booleans that prove compliance without revealing sensitive information. Revolutionary for KYC/AML compliance while preserving user privacy.",
    category: "Advanced",
    docsOutput: "docs/advanced/private-kyc.md",
    title: "Private KYC"
  },
  "private-payroll": {
    contract: "contracts/advanced/PrivatePayroll.sol",
    test: "test/advanced/PrivatePayroll.ts",
    description:
      "Confidential payroll system with encrypted salaries. Employers can add employees with encrypted salary amounts. Each employee can decrypt only their own salary - other salaries remain hidden. Demonstrates selective decryption permissions where different users see different encrypted values. Perfect for privacy-preserving HR systems.",
    category: "Advanced",
    docsOutput: "docs/advanced/private-payroll.md",
    title: "Private Payroll"
  },
  "public-decrypt-multiple-values": {
    contract: "contracts/basic/decryption/PublicDecryptMultipleValues.sol",
    test: "test/basic/decryption/PublicDecryptMultipleValues.ts",
    description:
      "Highest die roll game with public decryption of multiple values. Two players roll encrypted 8-sided dice, results are made publicly decryptable. Demonstrates handling multiple encrypted values in checkSignatures() where ORDER MATTERS - the cts[] array must match the order of values in the ABI-encoded result.",
    category: "Basic - Decryption",
    docsOutput: "docs/basic/decryption/public-decrypt-multiple-values.md",
    title: "Public Decrypt Multiple Values"
  },
  "public-decrypt-single-value": {
    contract: "contracts/basic/decryption/PublicDecryptSingleValue.sol",
    test: "test/basic/decryption/PublicDecryptSingleValue.ts",
    description:
      "Heads or Tails game with public, permissionless decryption. Demonstrates makePubliclyDecryptable() which allows ANYONE to decrypt the result (not just allowed users). Perfect for public game results, lottery winners, or voting tallies. Uses FHE.randEbool() for fair randomness and KMS-verified decryption proofs.",
    category: "Basic - Decryption",
    docsOutput: "docs/basic/decryption/public-decrypt-single-value.md",
    title: "Public Decrypt Single Value"
  },
  "user-decrypt-multiple-values": {
    contract: "contracts/basic/decryption/UserDecryptMultipleValues.sol",
    test: "test/basic/decryption/UserDecryptMultipleValues.ts",
    description:
      "Decrypting multiple encrypted values of different types for a user. Shows how to handle ebool, euint32, and euint64 in one contract. Each value requires individual permission grants - there's no batching for permissions (unlike input proofs). Demonstrates the pattern of granting allowThis() for each value separately.",
    category: "Basic - Decryption",
    docsOutput: "docs/basic/decryption/user-decrypt-multiple-values.md",
    title: "User Decrypt Multiple Values"
  },
  "user-decrypt-single-value": {
    contract: "contracts/basic/decryption/UserDecryptSingleValue.sol",
    test: "test/basic/decryption/UserDecryptSingleValue.ts",
    description:
      "User-controlled decryption with proper permission management. Demonstrates the critical two-step permission pattern: allowThis() grants the contract permission to store/compute, while allow() grants the user permission to decrypt. Missing either step causes decryption to fail. Includes examples of both correct and incorrect patterns.",
    category: "Basic - Decryption",
    docsOutput: "docs/basic/decryption/user-decrypt-single-value.md",
    title: "User Decrypt Single Value"
  },
  "encrypt-multiple-values": {
    contract: "contracts/basic/encryption/EncryptMultipleValues.sol",
    test: "test/basic/encryption/EncryptMultipleValues.ts",
    description:
      "Efficient handling of multiple encrypted values in one transaction. Demonstrates batched input validation where a single proof covers multiple encrypted values (ebool, euint32, eaddress), saving ~50k gas per additional value compared to separate proofs.",
    category: "Basic - Encryption",
    docsOutput: "docs/basic/encryption/encrypt-multiple-values.md",
    title: "Encrypt Multiple Values"
  },
  "encrypt-single-value": {
    contract: "contracts/basic/encryption/EncryptSingleValue.sol",
    test: "test/basic/encryption/EncryptSingleValue.ts",
    description:
      "Single value encryption with proof validation. Shows how to receive encrypted data from users, validate proofs, and grant proper permissions. Includes examples of common mistakes and the correct permission pattern (allowThis + allow).",
    category: "Basic - Encryption",
    docsOutput: "docs/basic/encryption/encrypt-single-value.md",
    title: "Encrypt Single Value"
  },
  "fhe-counter": {
    contract: "contracts/basic/encryption/FHECounter.sol",
    test: "test/basic/encryption/FHECounter.ts",
    description:
      "Confidential counter with encrypted increment/decrement operations. Demonstrates the complete FHE workflow: encryption, computation, and permission management. The counter value remains private, only accessible through decryption by authorized users.",
    category: "Basic - Encryption",
    docsOutput: "docs/basic/encryption/fhe-counter.md",
    title: "FHE Counter"
  },
  "fhe-add": {
    contract: "contracts/basic/fhe-operations/FHEAdd.sol",
    test: "test/basic/fhe-operations/FHEAdd.ts",
    description:
      "Introduction to homomorphic addition on encrypted values. Demonstrates the most fundamental FHE operation: adding two encrypted numbers without decrypting them. Shows the complete flow from receiving encrypted inputs, performing the addition, and granting permissions for both contract storage and user decryption.",
    category: "Basic - FHE Operations",
    docsOutput: "docs/basic/fhe-operations/fhe-add.md",
    title: "FHE Add"
  },
  "fhe-arithmetic": {
    contract: "contracts/basic/fhe-operations/FHEArithmetic.sol",
    test: "test/basic/fhe-operations/FHEArithmetic.ts",
    description:
      "Complete suite of FHE arithmetic operations on encrypted values. Covers all basic math: addition, subtraction, multiplication, division, remainder (modulo), minimum, and maximum. Includes gas cost comparisons and important limitations (e.g., division/remainder only work with plaintext divisors, not encrypted divisors).",
    category: "Basic - FHE Operations",
    docsOutput: "docs/basic/fhe-operations/fhe-arithmetic.md",
    title: "FHE Arithmetic"
  },
  "fhe-comparison": {
    contract: "contracts/basic/fhe-operations/FHEComparison.sol",
    test: "test/basic/fhe-operations/FHEComparison.ts",
    description:
      "Complete guide to encrypted comparisons and conditional selection. Covers all comparison operators (eq, ne, gt, lt, ge, le) that return encrypted booleans (ebool), and demonstrates FHE.select for branching without information leakage. Critical for implementing logic like \"find maximum\" or \"check threshold\" without revealing values.",
    category: "Basic - FHE Operations",
    docsOutput: "docs/basic/fhe-operations/fhe-comparison.md",
    title: "FHE Comparison"
  },
  "fhe-if-then-else": {
    contract: "contracts/basic/fhe-operations/FHEIfThenElse.sol",
    test: "test/basic/fhe-operations/FHEIfThenElse.ts",
    description:
      "Conditional logic without information leakage using FHE.select. Demonstrates how to implement if-then-else logic on encrypted values (computing max of two numbers). Using regular if/else would decrypt and leak which branch was taken. FHE.select evaluates BOTH branches and picks one based on the encrypted condition, preserving privacy.",
    category: "Basic - FHE Operations",
    docsOutput: "docs/basic/fhe-operations/fhe-if-then-else.md",
    title: "FHE If Then Else"
  },
  "fhe-access-control": {
    contract: "contracts/concepts/FHEAccessControl.sol",
    test: "test/concepts/FHEAccessControl.ts",
    description:
      "Master class for FHE permission patterns and access control. Explains the three permission types: allow() for permanent access, allowThis() for contract operations, and allowTransient() for temporary cross-contract calls. Includes correct and incorrect usage examples to prevent common decryption failures.",
    category: "Concepts",
    docsOutput: "docs/concepts/fhe-access-control.md",
    title: "FHE Access Control"
  },
  "fhe-anti-patterns": {
    contract: "contracts/concepts/FHEAntiPatterns.sol",
    test: "test/concepts/FHEAntiPatterns.ts",
    description:
      "Comprehensive guide to FHE anti-patterns and their solutions. Covers 9 critical mistakes: using if/else on encrypted values, incorrect permission patterns, require() statements that leak info, unbounded loops, noise accumulation, and deprecated APIs. Each pattern shows both ❌ WRONG and ✅ CORRECT implementations.",
    category: "Concepts",
    docsOutput: "docs/concepts/fhe-anti-patterns.md",
    title: "FHE Anti Patterns"
  },
  "fhe-handles": {
    contract: "contracts/concepts/FHEHandles.sol",
    test: "test/concepts/FHEHandles.ts",
    description:
      "Deep dive into FHE handles: what they are and how they work. Explains that handles are uint256 pointers to encrypted data, demonstrates three creation methods (fromExternal, asEuint, operations), and emphasizes immutability - every operation creates a NEW handle. Includes gas cost comparisons for different operations.",
    category: "Concepts",
    docsOutput: "docs/concepts/fhe-handles.md",
    title: "FHE Handles"
  },
  "fhe-input-proof": {
    contract: "contracts/concepts/FHEInputProof.sol",
    test: "test/concepts/FHEInputProof.ts",
    description:
      "Input proof validation and batching strategies in FHEVM. Explains why proofs are essential (prevent garbage data, wrong types, and replay attacks) and demonstrates the gas-efficient batching pattern where one proof validates multiple encrypted inputs, saving ~50k gas per additional value.",
    category: "Concepts",
    docsOutput: "docs/concepts/fhe-input-proof.md",
    title: "FHE Input Proof"
  },
  "encrypted-lottery": {
    contract: "contracts/gaming/EncryptedLottery.sol",
    test: "test/gaming/EncryptedLottery.ts",
    description:
      "Provably fair lottery with encrypted ticket numbers. Players buy tickets with encrypted numbers. Winning number is generated using FHE randomness. Winner is determined by comparing encrypted values without revealing losing tickets. Ensures fairness and privacy - no one can see ticket numbers before the draw.",
    category: "Gaming",
    docsOutput: "docs/gaming/encrypted-lottery.md",
    title: "Encrypted Lottery"
  },
  "encrypted-poker": {
    contract: "contracts/gaming/EncryptedPoker.sol",
    test: "test/gaming/EncryptedPoker.ts",
    description:
      "On-chain Texas Hold'em poker with encrypted hole cards. Two players receive encrypted hole cards that remain hidden throughout the game. Hand strength is computed using FHE operations. Winner is determined by comparing encrypted hand strengths. Demonstrates complex game logic with multiple encrypted states and conditional operations.",
    category: "Gaming",
    docsOutput: "docs/gaming/encrypted-poker.md",
    title: "Encrypted Poker"
  },
  "rock-paper-scissors": {
    contract: "contracts/gaming/RockPaperScissors.sol",
    test: "test/gaming/RockPaperScissors.ts",
    description:
      "Fair Rock-Paper-Scissors game with encrypted moves. Players submit encrypted moves (0=Rock, 1=Paper, 2=Scissors) ensuring neither player can see the other's choice before committing. Winner is determined using FHE operations and revealed publicly. No trusted third party needed - cryptography guarantees fairness.",
    category: "Gaming",
    docsOutput: "docs/gaming/rock-paper-scissors.md",
    title: "Rock Paper Scissors"
  },
  "erc7984": {
    contract: "contracts/openzeppelin/ERC7984.sol",
    test: "test/openzeppelin/ERC7984.ts",
    npmDependencies: {
      "@openzeppelin/contracts": "^5.4.0",
      "@openzeppelin/confidential-contracts": "^0.3.0"
    },
    description:
      "Confidential ERC20-compatible token using OpenZeppelin's ERC7984 standard. Implements a fully private token where balances and transfer amounts are encrypted. Compatible with standard ERC20 interfaces but with FHE under the hood. Supports both visible minting (owner knows amount) and confidential minting (fully private). Foundation for building private DeFi applications.",
    category: "Openzeppelin",
    docsOutput: "docs/openzeppelin/erc7984.md",
    title: "ERC7984"
  },
  "erc7984-erc20-wrapper": {
    contract: "contracts/openzeppelin/ERC7984ERC20Wrapper.sol",
    test: "test/openzeppelin/ERC7984ERC20Wrapper.ts",
    npmDependencies: {
      "@openzeppelin/contracts": "^5.4.0",
      "@openzeppelin/confidential-contracts": "^0.3.0"
    },
    dependencies: [
      "contracts/openzeppelin/mocks/ERC20Mock.sol"
    ],
    description:
      "Bridge between public ERC20 and confidential ERC7984 tokens. Allows users to wrap regular ERC20 tokens into privacy-preserving ERC7984 tokens (public → private) and unwrap them back (private → public). Wrapping is instant, unwrapping requires decryption proof from KMS. Essential for bringing existing tokens into the confidential ecosystem.",
    category: "Openzeppelin",
    docsOutput: "docs/openzeppelin/erc7984-erc20-wrapper.md",
    title: "ERC7984 ERC20 Wrapper"
  },
  "swap-erc7984-to-erc20": {
    contract: "contracts/openzeppelin/SwapERC7984ToERC20.sol",
    test: "test/openzeppelin/SwapERC7984ToERC20.ts",
    npmDependencies: {
      "@openzeppelin/contracts": "^5.4.0",
      "@openzeppelin/confidential-contracts": "^0.3.0"
    },
    dependencies: [
      "contracts/openzeppelin/mocks/ERC20Mock.sol",
      "contracts/openzeppelin/ERC7984.sol"
    ],
    description:
      "Atomic swap from confidential ERC7984 to public ERC20 tokens. Two-step process: (1) Initiate swap with encrypted amount, request decryption from KMS. (2) Finalize swap with decryption proof, receive ERC20 tokens. Demonstrates the FHEVM v0.9 public decryption flow with makePubliclyDecryptable() and checkSignatures() for trustless swaps.",
    category: "Openzeppelin",
    docsOutput: "docs/openzeppelin/swap-erc7984-to-erc20.md",
    title: "Swap ERC7984 To ERC20"
  },
  "swap-erc7984-to-erc7984": {
    contract: "contracts/openzeppelin/SwapERC7984ToERC7984.sol",
    test: "test/openzeppelin/SwapERC7984ToERC7984.ts",
    npmDependencies: {
      "@openzeppelin/confidential-contracts": "^0.3.0"
    },
    dependencies: [
      "contracts/openzeppelin/ERC7984.sol"
    ],
    description:
      "Fully private atomic swap between two confidential ERC7984 tokens. Both input and output amounts remain encrypted throughout the entire swap process. No decryption needed - amounts stay private from start to finish. Perfect for confidential DEX operations where trade sizes must remain hidden. The ultimate privacy-preserving token exchange.",
    category: "Openzeppelin",
    docsOutput: "docs/openzeppelin/swap-erc7984-to-erc7984.md",
    title: "Swap ERC7984 To ERC7984"
  },
  "vesting-wallet": {
    contract: "contracts/openzeppelin/VestingWallet.sol",
    test: "test/openzeppelin/VestingWallet.ts",
    npmDependencies: {
      "@openzeppelin/contracts": "^5.4.0",
      "@openzeppelin/confidential-contracts": "^0.3.0"
    },
    dependencies: [
      "contracts/openzeppelin/ERC7984.sol"
    ],
    description:
      "Time-locked vesting wallet with fully encrypted token amounts. Implements linear vesting for ERC7984 confidential tokens. Vesting schedule, amounts, and release calculations all happen on encrypted values using FHE operations. Beneficiary can release vested tokens over time without revealing the total allocation or vesting progress to observers.",
    category: "Openzeppelin",
    docsOutput: "docs/openzeppelin/vesting-wallet.md",
    title: "Vesting Wallet"
  }
};

// =============================================================================
// Category Configurations
// =============================================================================

export const CATEGORIES: Record<string, CategoryConfig> = {
  advanced: {
    name: "Advanced Examples",
    contracts: [
      {
        sol: "contracts/advanced/BlindAuction.sol",
        test: "test/advanced/BlindAuction.ts",
      },
      {
        sol: "contracts/advanced/EncryptedEscrow.sol",
        test: "test/advanced/EncryptedEscrow.ts",
      },
      {
        sol: "contracts/advanced/HiddenVoting.sol",
        test: "test/advanced/HiddenVoting.ts",
      },
      {
        sol: "contracts/advanced/PrivateKYC.sol",
        test: "test/advanced/PrivateKYC.ts",
      },
      {
        sol: "contracts/advanced/PrivatePayroll.sol",
        test: "test/advanced/PrivatePayroll.ts",
      }
    ],
  },
  basicdecryption: {
    name: "Basic - Decryption Examples",
    contracts: [
      {
        sol: "contracts/basic/decryption/PublicDecryptMultipleValues.sol",
        test: "test/basic/decryption/PublicDecryptMultipleValues.ts",
      },
      {
        sol: "contracts/basic/decryption/PublicDecryptSingleValue.sol",
        test: "test/basic/decryption/PublicDecryptSingleValue.ts",
      },
      {
        sol: "contracts/basic/decryption/UserDecryptMultipleValues.sol",
        test: "test/basic/decryption/UserDecryptMultipleValues.ts",
      },
      {
        sol: "contracts/basic/decryption/UserDecryptSingleValue.sol",
        test: "test/basic/decryption/UserDecryptSingleValue.ts",
      }
    ],
  },
  basicencryption: {
    name: "Basic - Encryption Examples",
    contracts: [
      {
        sol: "contracts/basic/encryption/EncryptMultipleValues.sol",
        test: "test/basic/encryption/EncryptMultipleValues.ts",
      },
      {
        sol: "contracts/basic/encryption/EncryptSingleValue.sol",
        test: "test/basic/encryption/EncryptSingleValue.ts",
      },
      {
        sol: "contracts/basic/encryption/FHECounter.sol",
        test: "test/basic/encryption/FHECounter.ts",
      }
    ],
  },
  basicfheoperations: {
    name: "Basic - FHE Operations Examples",
    contracts: [
      {
        sol: "contracts/basic/fhe-operations/FHEAdd.sol",
        test: "test/basic/fhe-operations/FHEAdd.ts",
      },
      {
        sol: "contracts/basic/fhe-operations/FHEArithmetic.sol",
        test: "test/basic/fhe-operations/FHEArithmetic.ts",
      },
      {
        sol: "contracts/basic/fhe-operations/FHEComparison.sol",
        test: "test/basic/fhe-operations/FHEComparison.ts",
      },
      {
        sol: "contracts/basic/fhe-operations/FHEIfThenElse.sol",
        test: "test/basic/fhe-operations/FHEIfThenElse.ts",
      }
    ],
  },
  concepts: {
    name: "Concepts Examples",
    contracts: [
      {
        sol: "contracts/concepts/FHEAccessControl.sol",
        test: "test/concepts/FHEAccessControl.ts",
      },
      {
        sol: "contracts/concepts/FHEAntiPatterns.sol",
        test: "test/concepts/FHEAntiPatterns.ts",
      },
      {
        sol: "contracts/concepts/FHEHandles.sol",
        test: "test/concepts/FHEHandles.ts",
      },
      {
        sol: "contracts/concepts/FHEInputProof.sol",
        test: "test/concepts/FHEInputProof.ts",
      }
    ],
  },
  gaming: {
    name: "Gaming Examples",
    contracts: [
      {
        sol: "contracts/gaming/EncryptedLottery.sol",
        test: "test/gaming/EncryptedLottery.ts",
      },
      {
        sol: "contracts/gaming/EncryptedPoker.sol",
        test: "test/gaming/EncryptedPoker.ts",
      },
      {
        sol: "contracts/gaming/RockPaperScissors.sol",
        test: "test/gaming/RockPaperScissors.ts",
      }
    ],
  },
  openzeppelin: {
    name: "Openzeppelin Examples",
    contracts: [
      {
        sol: "contracts/openzeppelin/ERC7984.sol",
        test: "test/openzeppelin/ERC7984.ts",
      },
      {
        sol: "contracts/openzeppelin/ERC7984ERC20Wrapper.sol",
        test: "test/openzeppelin/ERC7984ERC20Wrapper.ts",
      },
      {
        sol: "contracts/openzeppelin/SwapERC7984ToERC20.sol",
        test: "test/openzeppelin/SwapERC7984ToERC20.ts",
      },
      {
        sol: "contracts/openzeppelin/SwapERC7984ToERC7984.sol",
        test: "test/openzeppelin/SwapERC7984ToERC7984.ts",
      },
      {
        sol: "contracts/openzeppelin/VestingWallet.sol",
        test: "test/openzeppelin/VestingWallet.ts",
      }
    ],
  }
};

// =============================================================================
// Helper Functions
// =============================================================================

/**
 * Get list of example names
 */
export function getExampleNames(): string[] {
  return Object.keys(EXAMPLES);
}

/**
 * Get list of category names
 */
export function getCategoryNames(): string[] {
  return Object.keys(CATEGORIES);
}

/**
 * Get example by name
 */
export function getExample(name: string): ExampleConfig | undefined {
  return EXAMPLES[name];
}

/**
 * Get category by name
 */
export function getCategory(name: string): CategoryConfig | undefined {
  return CATEGORIES[name];
}

/**
 * Generate consistent docs filename with fhe- prefix
 */
export function getDocsFileName(exampleName: string): string {
  return exampleName.startsWith("fhe-") ? exampleName : `fhe-${exampleName}`;
}
